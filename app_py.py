# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z3vaB2P0wtgNXP-30Lbz5naamEdWymdp
"""

# -*- coding: utf-8 -*-
"""Updated app.py for LSTM Stock Prediction with Dropout Fix"""

import streamlit as st
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import precision_score, recall_score, f1_score, classification_report
import warnings

warnings.filterwarnings("ignore", category=UserWarning, module='tensorflow')

# Fix reproducibility for dropout
tf.keras.utils.set_random_seed(42)
try:
    tf.config.experimental.enable_op_determinism()
except Exception:
    pass  # Not supported in older TF versions

st.title("ðŸ“ˆ LSTM Stock Price Prediction")

stock_options = {
    "Technology": ["AAPL", "MSFT", "GOOGL", "NVDA"],
    "Finance": ["JPM", "GS", "MS"],
    "Healthcare": ["JNJ", "PFE", "MRK"],
    "Consumer Discretionary": ["AMZN", "TSLA", "HD"]
}

sector = st.selectbox("Select Sector", list(stock_options.keys()))
symbol = st.selectbox("Select Stock", stock_options[sector])

@st.cache_data(show_spinner=False)
def generate_synthetic_data(seed=42):
    np.random.seed(seed)
    data = np.cumsum(np.random.randn(500) * 2 + 0.5) + 100
    return data.astype(np.float32).reshape(-1, 1)

@st.cache_resource(show_spinner=False)
def build_and_train_model(X, y):
    model = tf.keras.Sequential([
        tf.keras.layers.LSTM(50, return_sequences=True, input_shape=(X.shape[1], 1)),
        tf.keras.layers.Dropout(0.2, seed=42),
        tf.keras.layers.LSTM(50),
        tf.keras.layers.Dropout(0.2, seed=42),
        tf.keras.layers.Dense(1)
    ])
    model.compile(optimizer='adam', loss='mean_squared_error')
    model.fit(X, y, epochs=20, batch_size=32, verbose=0)
    return model

if symbol:
    st.write(f"Generating synthetic stock data for: `{symbol}`")
    data = generate_synthetic_data()

    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_data = scaler.fit_transform(data)

    sequence_length = 60
    X, y = [], []
    for i in range(sequence_length, len(scaled_data)):
        X.append(scaled_data[i - sequence_length:i, 0])
        y.append(scaled_data[i, 0])
    X, y = np.array(X), np.array(y)
    X = X.reshape(X.shape[0], X.shape[1], 1)

    with st.spinner("Training the LSTM model..."):
        model = build_and_train_model(X, y)
    st.success("âœ… Model trained!")

    predicted_prices_scaled = model.predict(X)
    predicted_prices = scaler.inverse_transform(predicted_prices_scaled.reshape(-1, 1))
    true_prices = scaler.inverse_transform(y.reshape(-1, 1))

    y_true = (np.diff(true_prices.flatten(), prepend=true_prices[0]) > 0).astype(int)
    y_pred = (np.diff(predicted_prices.flatten(), prepend=predicted_prices[0]) > 0).astype(int)

    st.subheader("ðŸ“Š Classification Report")
    st.write(f"**Precision**: {precision_score(y_true, y_pred):.2f}")
    st.write(f"**Recall**: {recall_score(y_true, y_pred):.2f}")
    st.write(f"**F1 Score**: {f1_score(y_true, y_pred):.2f}")
    st.text(classification_report(y_true, y_pred))

    last_60_days = scaled_data[-60:]
    future_input = last_60_days.reshape(1, 60, 1)
    future_price_scaled = model.predict(future_input)
    future_price = scaler.inverse_transform(future_price_scaled)

    st.subheader("ðŸ”® Predicted Price for Next Day:")
    st.success(f"${future_price.flatten()[0]:.2f}")

    st.subheader("ðŸ“‰ Actual vs. Predicted Stock Prices")
    fig = plt.figure(figsize=(10, 5))
    plt.plot(true_prices, label='Actual Price', color='blue')
    plt.plot(predicted_prices, label='Predicted Price', color='orange')
    plt.xlabel("Days")
    plt.ylabel("Price")
    plt.title(f"Stock Price Prediction for {symbol}")
    plt.legend()
    st.pyplot(fig)
    plt.close(fig)
