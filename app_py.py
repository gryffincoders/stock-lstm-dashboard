# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z3vaB2P0wtgNXP-30Lbz5naamEdWymdp
"""

import streamlit as st
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import precision_score, recall_score, f1_score, classification_report
import warnings

# Suppress Keras warnings
warnings.filterwarnings("ignore", category=UserWarning, module='keras')

# Title
st.set_page_config(page_title="LSTM Stock Predictor", layout="wide")
st.title("📈 LSTM Stock Price Prediction")

# Input
symbol = st.text_input("Enter Stock Symbol", "AAPL")

if symbol:
    st.write(f"🔄 Generating synthetic stock data for: `{symbol}`")

    # Generate synthetic stock data
    np.random.seed(42)
    data = np.cumsum(np.random.randn(500, 1) * 2 + 0.5) + 100  # Simulated stock price
    data = np.array(data).astype(np.float32)  # Ensure proper numeric format

    # Ensure proper numeric format and shape before scaling
    data = np.array(data).reshape(-1, 1).astype(np.float32)
    scaled_data = scaler.fit_transform(data)

    

    # Prepare sequences
    sequence_length = 60
    X, y = [], []
    for i in range(sequence_length, len(scaled_data)):
        X.append(scaled_data[i - sequence_length:i, 0])
        y.append(scaled_data[i, 0])
    X, y = np.array(X), np.array(y)
    X = X.reshape(X.shape[0], X.shape[1], 1)

    # Build LSTM model
    model = tf.keras.Sequential([
        tf.keras.layers.LSTM(50, return_sequences=True, input_shape=(X.shape[1], 1)),
        tf.keras.layers.Dropout(0.2),
        tf.keras.layers.LSTM(50),
        tf.keras.layers.Dropout(0.2),
        tf.keras.layers.Dense(1)
    ])
    model.compile(optimizer='adam', loss='mean_squared_error')

    # Train model
    with st.spinner("⏳ Training the LSTM model..."):
        model.fit(X, y, epochs=20, batch_size=32, verbose=0)
    st.success("✅ Model trained successfully!")

    # Predict prices
    predicted_prices = model.predict(X)
    predicted_prices = scaler.inverse_transform(predicted_prices.reshape(-1, 1))
    true_prices = scaler.inverse_transform(y.reshape(-1, 1))

    # Binary classification for performance metrics
    y_true = (np.diff(true_prices.flatten(), prepend=true_prices[0]) > 0).astype(int)
    y_pred = (np.diff(predicted_prices.flatten(), prepend=predicted_prices[0]) > 0).astype(int)

    st.subheader("📊 Classification Metrics")
    st.write(f"**Precision:** {precision_score(y_true, y_pred):.2f}")
    st.write(f"**Recall:** {recall_score(y_true, y_pred):.2f}")
    st.write(f"**F1 Score:** {f1_score(y_true, y_pred):.2f}")
    st.text(classification_report(y_true, y_pred))

    # Predict next day
    last_60_days = scaled_data[-60:]
    future_input = last_60_days.reshape(1, 60, 1)
    future_price_scaled = model.predict(future_input)
    future_price = scaler.inverse_transform(future_price_scaled)
    st.subheader("🔮 Predicted Price for Next Day:")
    st.success(f"${future_price.flatten()[0]:.2f}")

    # Plot results
    st.subheader("📉 Actual vs Predicted Stock Prices")
    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(true_prices, label='Actual Price', color='blue')
    ax.plot(predicted_prices, label='Predicted Price', color='orange')
    ax.set_xlabel("Days")
    ax.set_ylabel("Price")
    ax.set_title(f"Stock Price Prediction for {symbol}")
    ax.legend()
    st.pyplot(fig)
